<svelte:window on:keydown="handleKeydown(event)" on:keyup="set({ _keyPressed: false })"/>

<div class="clip">
	<div
		ref:container
		class="layout"
		style="--thickness: {thickness}; --draggable: calc({thickness} + {padding}); --color: {color}"
	>
		{#each _panes as pane (pane.id)}
			<Pane {_keyPressed} {pane} {component} on:split="split(pane, event)"/>
		{/each}

		{#each _dividers as divider (divider.id)}
			<Divider {divider} on:mousedown="start(divider)"/>
		{/each}

		{#if _dragging}
			<div
				class="overlay {_dragging.type}"
				on:mousemove="drag(event)"
				on:mouseup="end(event)"
				on:mouseleave="end(event)"
			></div>
		{/if}
	</div>
</div>

<style>
	.clip, .overlay {
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}

	.clip {
		position: absolute;
		overflow: hidden;
	}

	.overlay {
		position: fixed;
		z-index: 2147483647;
	}

	.overlay.vertical {
		cursor: col-resize;
	}

	.overlay.horizontal {
		cursor: row-resize;
	}

	.layout {
		position: absolute;
		width: calc(100% + var(--thickness));
		height: calc(100% + var(--thickness));
		overflow: hidden;
		margin: calc(0px - var(--thickness) / 2);
	}
</style>

<script>
	import * as constants from './constants.js';
	import { removeFromArray, clamp } from './utils.js';

	class Rect {
		constructor(id, x, y, w, h, prev, next) {
			this.id = id;
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;

			this.prev = prev;
			this.next = next;

			this.parent = null;
		}

		bounds(rect) {
			const width = rect.right - rect.left;
			const height = rect.bottom - rect.top;

			return {
				left: rect.left + width * this.getLeft(),
				top: rect.top + height * this.getTop(),
				width: width * this.getWidth(),
				height: height * this.getHeight()
			};
		}

		getLeft() {
			let left = this.x;

			let node = this;
			while (node = node.parent) left = node.x + (node.w * left);

			return left;
		}

		getTop() {
			let top = this.y;

			let node = this;
			while (node = node.parent) top = node.y + (node.h * top);

			return top;
		}

		getWidth() {
			let width = this.w;

			let node = this;
			while (node = node.parent) width *= node.w;

			return width;
		}

		getHeight() {
			let height = this.h;

			let node = this;
			while (node = node.parent) height *= node.h;

			return height;
		}

		setRange(a, b) {
			if (this.parent.type === constants.COLUMN) {
				this.y = a;
				this.h = (b - a);
			} else {
				this.x = a;
				this.w = (b - a);
			}
		}
	}

	class Pane extends Rect {
		constructor(id, { x, y, w, h, prev, next }) {
			super(id, x, y, w, h, prev, next);
			this.id = id;
		}

		destroy(panes, dividers) {
			const index = panes.indexOf(this);
			if (index === -1) throw new Error(`Unexpected error`);
			panes.splice(index, 1);
		}

		toJSON() {
			return {
				id: this.id,
				type: 'pane',
				x: this.x,
				y: this.y,
				w: this.w,
				h: this.h,
				prev: this.prev && this.prev.id,
				next: this.next && this.next.id
			};
		}
	}

	class Group extends Rect {
		constructor(id, type, { x, y, w, h, prev, next }) {
			super(id, x, y, w, h, prev, next);

			this.type = type;
			this.children = [];
			this.dividers = [];
		}

		addChild(child) {
			this.children.push(child);
			child.parent = this;
		}

		replaceChild(child, replacement) {
			const index = this.children.indexOf(child);
			if (index === -1) throw new Error(`Unexpected error`);
			this.children[index] = replacement;

			replacement.parent = this;

			child.parent = replacement;
			replacement.children.push(child);
		}

		destroy(panes, dividers) {
			let i = this.children.length;
			while (i--) this.children[i].destroy(panes, dividers);

			i = this.dividers.length;
			while (i--) this.dividers[i].destroy(panes, dividers);
		}

		toJSON() {
			return {
				id: this.id,
				type: 'group',
				direction: this.type, // TODO confusing
				x: this.x,
				y: this.y,
				w: this.w,
				h: this.h,
				prev: this.prev && this.prev.id,
				next: this.next && this.next.id,
				children: this.children.map(child => child.toJSON())
			};
		}
	}

	class Divider {
		constructor({ id, type, group, position, prev, next }) {
			this.id = id;
			this.type = type;
			this.parent = group;
			this.position = position;
			this.prev = prev;
			this.next = next;

			group.dividers.push(this);
		}

		destroy(panes, dividers) {
			const index = dividers.indexOf(this);
			if (index === -1) throw new Error(`Unexpected error`);
			dividers.splice(index, 1);
		}
	}

	const defaultLayout = {
		root: {
			id: 0,
			type: 'group',
			direction: constants.COLUMN,
			x: 0,
			y: 0,
			w: 1,
			h: 1,
			prev: null,
			next: null,
			children: [
				{
					type: 'pane',
					id: 1,
					x: 0,
					y: 0,
					w: 1,
					h: 1,
					prev: null,
					next: null
				}
			]
		}
	};

	export default {
		components: {
			Pane: './Pane.html',
			Divider: './Divider.html'
		},

		data() {
			return {
				thickness: '1px',
				padding: '6px',
				color: 'white',
				layout: defaultLayout,

				_pid: 1,
				_did: 0,
				_panes: [],
				_dividers: [],
				_dragging: null,
				_keyPressed: false
			};
		},

		onstate({ changed, current }) {
			if (this.updating) return;

			if (changed.layout) {
				let { _did } = this.get();

				const panes = [];
				const dividers = [];

				const lookup = {};
				let maxid = 0;

				const createGroup = data => {
					const group = new Group(data.id, data.direction, {
						x: data.x,
						y: data.y,
						w: data.w,
						h: data.h,
						prev: null,
						next: null
					});

					lookup[data.id] = group;

					let lastChild = null;

					data.children.sort((a, b) => {
						if (group.type === constants.COLUMN) return a.y - b.y;
						return a.x - b.x;
					}).forEach((data, i) => {
						let child;

						if (data.id > maxid) maxid = data.id;

						if (data.type === 'group') {
							child = createGroup(data);
						} else {
							child = new Pane(data.id, {
								x: data.x,
								y: data.y,
								w: data.w,
								h: data.h,
								prev: null,
								next: null
							});

							lookup[data.id] = child;
							panes.push(child);
						}

						group.addChild(child);

						if (i > 0) {
							child.prev = lastChild;
							lastChild.next = child;

							const dividerType = group.type === constants.COLUMN ? 'horizontal' : 'vertical';

							const divider = new Divider({
								id: _did++,
								type: dividerType,
								group,
								position: dividerType === 'horizontal' ? child.y : child.x,
								prev: lastChild,
								next: child
							});

							dividers.push(divider);
						}

						lastChild = child;
					});

					return group;
				};

				const root = createGroup(current.layout ? current.layout.root : defaultLayout.root);

				this.set({
					_pid: maxid + 1,
					_did,
					_root: root,
					_panes: panes,
					_dividers: dividers
				});
			}
		},

		methods: {
			updateLayout() {
				const { _root } = this.get();
				const layout = {
					root: _root.toJSON()
				};

				this.updating = true;
				this.set({ layout });
				this.updating = false;
			},

			split(pane, event) {
				const { left, right, top, bottom } = this.refs.container.getBoundingClientRect();
				let { _pid, _did, _panes, _dividers } = this.get();
				const { edge, clientX, clientY } = event;

				const dividerType = edge === constants.NORTH || edge === constants.SOUTH
					? 'horizontal'
					: 'vertical';

				const groupType = dividerType === 'horizontal'
					? constants.COLUMN
					: constants.ROW;

				let group = pane.parent;

				const newGroup = group && group.type === groupType
					? null
					: new Group(_pid++, groupType, pane);

				if (newGroup) {
					pane.x = pane.y = 0;
					pane.w = pane.h = 1;

					pane.parent.replaceChild(pane, newGroup);
					group = newGroup;

					if (pane.next) pane.next.prev = newGroup;
					if (pane.prev) pane.prev.next = newGroup;

					pane.next = pane.prev = null;
				}

				const bounds = group.bounds(this.refs.container.getBoundingClientRect());

				const newPane = new Pane(_pid++, pane);
				group.addChild(newPane);

				const divider = new Divider({
					id: _did++,
					type: dividerType,
					group,
					position: null,
					prev: null,
					next: null
				});

				if (groupType === constants.COLUMN) {
					const y = (clientY - bounds.top) / bounds.height;
					const d = y - pane.y;

					divider.position = y;

					if (edge === constants.NORTH) {
						newPane.h = d;
						pane.y = y;
						pane.h -= d;
					} else {
						newPane.y = y;
						newPane.h = pane.h - d;
						pane.h  = d;
					}
				} else {
					const x = (clientX - bounds.left) / bounds.width;
					const d = x - pane.x;

					divider.position = x;

					if (edge === constants.WEST) {
						newPane.w = d;
						pane.x = x;
						pane.w -= d;
					} else {
						newPane.x = x;
						newPane.w = pane.w - d;
						pane.w  = d;
					}
				}

				if (edge === constants.NORTH || edge === constants.WEST) {
					if (pane.prev) pane.prev.next = newPane;

					pane.prev = divider;
					newPane.next = divider;

					divider.prev = newPane;
					divider.next = pane;
				} else {
					if (pane.next) pane.next.prev = newPane;

					pane.next = divider;
					newPane.prev = divider;

					divider.prev = pane;
					divider.next = newPane;
				}

				_panes.push(newPane);
				_dividers.push(divider);

				this.set({
					_pid,
					_did,
					_panes,
					_dividers,
					_dragging: divider
				});

				this._userSelect = document.body.style.userSelect;
				document.body.style.userSelect = 'none';

				this.updateLayout();
			},

			start(divider) {
				this._userSelect = document.body.style.userSelect;
				document.body.style.userSelect = 'none';

				this.set({ _dragging: divider });
			},

			drag(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return;

				const bounds = _dragging.parent.bounds(this.refs.container.getBoundingClientRect());

				const prev = _dragging.prev;
				const next = _dragging.next;

				let min;
				let max;
				let position;

				if (_dragging.type === 'vertical') {
					min = prev.x;
					max = next.x + next.w;
					position = clamp((event.clientX - bounds.left) / bounds.width, min, max);
				} else {
					min = prev.y;
					max = next.y + next.h;
					position = clamp((event.clientY - bounds.top) / bounds.height, min, max);
				}

				prev.setRange(min, position);
				next.setRange(position, max);

				_dragging.position = position;

				this.set({ _panes, _dividers });
			},

			end(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return;

				this.drag(event);

				const prevSize = _dragging.type === 'vertical'
					? _dragging.prev.w
					: _dragging.prev.h;

				const min = Math.min(prevSize, _dragging.type === 'vertical'
					? _dragging.next.w
					: _dragging.next.h)

				if (min < 0.0001) {
					removeFromArray(_dragging.parent.dividers, _dragging);
					removeFromArray(_dividers, _dragging);

					if (prevSize < 0.0001) {
						const mergedDivider = _dragging.prev.prev;

						_dragging.next.prev = mergedDivider;
						if (mergedDivider) mergedDivider.next = _dragging.next;

						_dragging.prev.destroy(_panes, _dividers);
						if (_dragging.prev.parent) {
							removeFromArray(_dragging.prev.parent.children, _dragging.prev);
						}
					} else {
						const mergedDivider = _dragging.next.next;

						_dragging.prev.next = mergedDivider;
						if (mergedDivider) mergedDivider.prev = _dragging.prev;

						_dragging.next.destroy(_panes, _dividers);
						if (_dragging.next.parent) {
							removeFromArray(_dragging.next.parent.children, _dragging.next);
						}
					}
				}

				this.set({ _panes, _dividers, _dragging: false });
				document.body.style.userSelect = this._userSelect;

				this.updateLayout();
			},

			handleKeydown(event) {
				this.set({
					_keyPressed: event.which === constants.KEYCODE
				});
			}
		}
	};
</script>
<div
	ref:container
	class="layout"
	on:mousemove="drag(event)"
	on:mouseup="end(event)"
	on:mouseleave="end(event)"
>
	{#each _panes as pane (pane.id)}
		<Pane {pane} {component} on:split="split(pane, event)"/>
	{/each}

	{#each _dividers as divider (divider.id)}
		<Divider {divider} on:mousedown="set({ _dragging: !event.metaKey && divider })"/>
	{/each}
</div>

<style>
	.layout {
		position: absolute;
		width: 100%;
		height: 100%;
		overflow: hidden;
	}
</style>

<script>
	import * as constants from './constants.js';

	class Pane {
		constructor(opts, id) {
			this.id = id;
			this.group = null;

			this.top = opts.top;
			this.left = opts.left;
			this.width = opts.width;
			this.height = opts.height;

			this.north = opts.north;
			this.south = opts.south;
			this.east = opts.east;
			this.west = opts.west;
		}

		destroy(panes) {
			removeFromArray(panes, this);
		}

		setHorizontalRange(x1, x2) {
			this.left = x1;
			this.width = x2 - x1;
		}

		// setLeft(left) {
		// 	this.left = left;
		// }

		setTop(top) {
			this.top = top;
		}

		// setWidth(width) {
		// 	this.width = width;
		// }

		setHeight(height) {
			this.height = height;
		}
	}

	class Group {
		constructor(child, type) {
			this.type = type;
			this.children = [child];
			this.dividers = [];

			this.top = child.top;
			this.left = child.left;
			this.width = child.width;
			this.height = child.height;

			this.north = child.north;
			this.south = child.south;
			this.east = child.east;
			this.west = child.west;

			child.north = child.south = child.west = child.east = null;

			if (this.north) this.north.after = this;
			if (this.south) this.south.before = this;
			if (this.west) this.west.after = this;
			if (this.east) this.east.before = this;
		}

		destroy(panes, dividers) {
			let i = this.dividers.length;
			while (i--) removeFromArray(dividers, this.dividers[i]);

			i = this.children.length;
			while (i--) this.children[i].destroy(panes, dividers);
		}

		addChild(child) {
			this.children.push(child);
		}

		replaceChild(child, replacement) {
			const index = this.children.indexOf(child);
			if (index === -1) throw new Error(`Unexpected error`);
			this.children[index] = replacement;
		}

		setHorizontalRange(x1, x2) {
			const width = x2 - x1;
			let i = this.children.length;

			if (this.type === constants.COLUMN) {
				while (i--) this.children[i].setHorizontalRange(x1, x2);
			} else {
				const f = width / this.width;

				while (i--) {
					const child = this.children[i];

					const cx1 = x1 + f * (child.left - this.left);
					const cx2 = cx1 + f * child.width;

					child.setHorizontalRange(cx1, cx2);

					// child.setLeft(this.left + f * (child.left - this.left));
					// child.setWidth(child.width * f);
				}

				i = this.dividers.length;
				while (i--) {
					const divider = this.dividers[i];
					divider.position = x1 + f * (divider.position - this.left);
				}
			}

			this.left = x1;
			this.width = width;
		}

		// setLeft(left) {
		// 	let i = this.children.length;
		// 	while (i--) this.children[i].setLeft(left);
		// 	this.left = left;
		// }

		setTop(top) {
			let i = this.children.length;
			while (i--) this.children[i].setTop(top);
			this.top = top;
		}

		// setWidth(width) {
		// 	let i = this.children.length;

		// 	if (this.type === constants.COLUMN) {
		// 		while (i--) this.children[i].setWidth(width);
		// 	} else {
		// 		const f = width / this.width;

		// 		while (i--) {
		// 			const child = this.children[i];
		// 			child.setLeft(this.left + f * (child.left - this.left));
		// 			child.setWidth(child.width * f);
		// 		}

		// 		i = this.dividers.length;
		// 		while (i--) {
		// 			const divider = this.dividers[i];
		// 			divider.position = this.left + f * (divider.position - this.left);
		// 		}
		// 	}

		// 	this.width = width;
		// }

		setHeight(height) {
			let i = this.children.length;

			if (this.type === constants.ROW) {
				while (i--) this.children[i].setHeight(height);
			} else {
				const f = height / this.height;

				while (i--) {
					const child = this.children[i];
					child.setTop(this.top + f * (child.top - this.top));
					child.setHeight(child.height * f);
				}

				i = this.dividers.length;
				while (i--) {
					const divider = this.dividers[i];
					divider.position = this.top + f * (divider.position - this.top);
				}
			}

			this.height = height;
		}
	}

	class Divider {
		constructor({ id, direction, group, position, before, after }) {
			this.id = id;
			this.direction = direction;
			this.group = group;
			this.position = position;
			this.before = before;
			this.after = after;
		}
	}

	function clamp(num, min, max) {
		if (num < min) return min;
		if (num > max) return max;
		return num;
	}

	function removeFromArray(array, item) {
		const index = array.indexOf(item);
		if (index === -1) throw new Error('Unexpected error');
		array.splice(index, 1);
	}

	export default {
		components: {
			Pane: './Pane.html',
			Divider: './Divider.html'
		},

		data() {
			const pane = new Pane({
				top: 0,
				left: 0,
				width: 1,
				height: 1
			}, 1);

			return {
				_pid: 2,
				_did: 1,
				_panes: [pane],
				_dividers: []
			};
		},

		methods: {
			split(pane, event) {
				const { left, right, top, bottom } = this.refs.container.getBoundingClientRect();
				let { _pid, _did, _panes, _dividers } = this.get();
				const { edge, clientX, clientY } = event;

				const direction = edge === constants.NORTH || edge === constants.SOUTH
					? constants.HORIZONTAL
					: constants.VERTICAL;

				let group = pane.group;

				const newPane = new Pane(pane, _pid++);

				const type = direction === constants.HORIZONTAL
					? constants.COLUMN
					: constants.ROW;

				const newGroup = group && group.type === type
					? null
					: new Group(pane, type);

				if (newGroup) {
					if (pane.group) pane.group.replaceChild(pane, newGroup);
					group = newGroup;
				}

				group.addChild(newPane);
				pane.group = group;
				newPane.group = group;

				const x = (event.clientX - left) / (right - left);
				const y = (event.clientY - top) / (bottom - top);

				const divider = new Divider({
					id: _did++,
					direction,
					group,
					position: edge === constants.EAST || edge === constants.WEST
						? x
						: y,
					before: edge === constants.NORTH || edge === constants.WEST
						? newPane
						: pane,
					after: edge === constants.NORTH || edge === constants.WEST
						? pane
						: newPane
				});

				switch (edge) {
					case constants.NORTH:
						pane.height -= (y - pane.top);
						newPane.top = pane.top;

						newPane.height = y - pane.top;
						pane.top = y;

						if (pane.north) pane.north.after = newPane;

						pane.north = divider;
						newPane.south = divider;

						break;

					case constants.SOUTH:
						newPane.height = (pane.top + pane.height) - y;
						pane.height = (y - pane.top);

						newPane.top = y;

						if (pane.south) pane.south.before = newPane;

						pane.south = divider;
						newPane.north = divider;

						break;

					case constants.EAST:
						newPane.left = x;
						newPane.width = (pane.left + pane.width) - x;

						pane.width = x - pane.left;

						if (pane.east) pane.east.before = newPane;

						pane.east = divider;
						newPane.west = divider;

						break;

					case constants.WEST:
						newPane.left = pane.left;
						newPane.width = (x - pane.left);

						pane.left = x;
						pane.width -= newPane.width;

						if (pane.west) pane.west.after = newPane;

						pane.west = divider;
						newPane.east = divider;

						break;
				}

				group.dividers.push(divider);

				_panes.push(newPane);
				_dividers.push(divider);

				this.set({
					_pid,
					_did,
					_panes,
					_dividers,
					_dragging: divider
				});
			},

			drag(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return

				const { left, top, right, bottom } = this.refs.container.getBoundingClientRect();

				const before = _dragging.before;
				const after = _dragging.after;

				let position;

				if (_dragging.direction === constants.VERTICAL) {
					const min = before.left;
					const max = after.left + after.width;
					position = clamp((event.clientX - left) / (right - left), min, max);

					const d = position - _dragging.position;

					before.setHorizontalRange(min, position);
					after.setHorizontalRange(position, max);

					// before.setWidth(before.width + d);
					// after.setWidth(after.width - d);
					// after.setLeft(after.left + d);
				} else {
					const min = before.top;
					const max = after.top + after.height;
					position = clamp((event.clientY - top) / (bottom - top), min, max);

					const d = position - _dragging.position;

					before.setHeight(before.height + d);
					after.setHeight(after.height - d);
					after.setTop(after.top + d);
				}

				_dragging.position = position;

				this.set({ _panes, _dividers });
			},

			end(event) {
				const { _panes, _dividers, _dragging } = this.get();
				if (!_dragging) return;

				this.drag(event);

				if (_dragging.direction === constants.VERTICAL) {
					if (_dragging.before.width < 0.0001 || _dragging.after.width < 0.0001) {
						removeFromArray(_dragging.group.dividers, _dragging);
						removeFromArray(_dividers, _dragging);

						if (_dragging.before.width < 0.0001) {
							const mergedDivider = _dragging.before.west;

							_dragging.after.west = mergedDivider;
							if (mergedDivider) mergedDivider.after = _dragging.after;

							_dragging.before.destroy(_panes, _dividers);
							if (_dragging.before.group) {
								removeFromArray(_dragging.before.group.children, _dragging.before);
							}
						} else {
							const mergedDivider = _dragging.after.east;

							_dragging.before.east = mergedDivider;
							if (mergedDivider) mergedDivider.before = _dragging.before;

							_dragging.after.destroy(_panes, _dividers);
							if (_dragging.after.group) {
								removeFromArray(_dragging.after.group.children, _dragging.after);
							}
						}
					}
				} else {
					if (_dragging.before.height < 0.0001 || _dragging.after.height < 0.0001) {
						removeFromArray(_dragging.group.dividers, _dragging);
						removeFromArray(_dividers, _dragging);

						if (_dragging.before.height < 0.0001) {
							const mergedDivider = _dragging.before.north;

							_dragging.after.north = mergedDivider;
							if (mergedDivider) mergedDivider.after = _dragging.after;

							_dragging.before.destroy(_panes, _dividers);
							if (_dragging.before.group) {
								removeFromArray(_dragging.before.group.children, _dragging.before);
							}
						} else {
							const mergedDivider = _dragging.after.south;

							_dragging.before.south = mergedDivider;
							if (mergedDivider) mergedDivider.before = _dragging.before;

							_dragging.after.destroy(_panes, _dividers);
							if (_dragging.after.group) {
								removeFromArray(_dragging.after.group.children, _dragging.after);
							}
						}
					}
				}

				this.set({ _panes, _dividers, _dragging: false });
			}
		}
	};
</script>